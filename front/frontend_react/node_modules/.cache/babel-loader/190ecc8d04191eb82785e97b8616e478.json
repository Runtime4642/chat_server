{"ast":null,"code":"'use strict';\n\nvar t = require('tcomb');\n\nvar stringify = t.stringify;\nvar noobj = {};\nvar ValidationError = t.struct({\n  message: t.Any,\n  actual: t.Any,\n  expected: t.Any,\n  path: t.list(t.union([t.String, t.Number]))\n}, 'ValidationError');\n\nfunction getDefaultValidationErrorMessage(actual, expected, path) {\n  var expectedName = t.getTypeName(expected);\n  var to = path.length ? '/' + path.join('/') + ': ' + expectedName : expectedName;\n  return 'Invalid value ' + stringify(actual) + ' supplied to ' + to;\n}\n\nfunction getValidationErrorMessage(actual, expected, path, context) {\n  if (t.Function.is(expected.getValidationErrorMessage)) {\n    return expected.getValidationErrorMessage(actual, path, context);\n  } else {\n    return getDefaultValidationErrorMessage(actual, expected, path);\n  }\n}\n\nValidationError.of = function (actual, expected, path, context) {\n  return new ValidationError({\n    message: getValidationErrorMessage(actual, expected, path, context),\n    actual: actual,\n    expected: expected,\n    path: path\n  });\n};\n\nvar ValidationResult = t.struct({\n  errors: t.list(ValidationError),\n  value: t.Any\n}, 'ValidationResult');\n\nValidationResult.prototype.isValid = function () {\n  return !this.errors.length;\n};\n\nValidationResult.prototype.firstError = function () {\n  return this.isValid() ? null : this.errors[0];\n};\n\nValidationResult.prototype.toString = function () {\n  if (this.isValid()) {\n    return '[ValidationResult, true, ' + stringify(this.value) + ']';\n  } else {\n    return '[ValidationResult, false, (' + this.errors.map(function (err) {\n      return stringify(err.message);\n    }).join(', ') + ')]';\n  }\n};\n\nfunction validate(x, type, options) {\n  options = options || {};\n  var path = t.Array.is(options) ? options : options.path || [];\n  return new ValidationResult(recurse(x, type, path, options));\n}\n\nfunction recurse(x, type, path, options) {\n  if (t.isType(type)) {\n    return validators[type.meta.kind](x, type, path, options);\n  } else {\n    return validators.es6classes(x, type, path, options);\n  }\n}\n\nvar validators = validate.validators = {};\n\nvalidators.es6classes = function validateES6Classes(x, type, path, options) {\n  return {\n    value: x,\n    errors: x instanceof type ? [] : [ValidationError.of(x, type, path, options.context)]\n  };\n}; // irreducibles and enums\n\n\nvalidators.irreducible = validators.enums = function validateIrreducible(x, type, path, options) {\n  return {\n    value: x,\n    errors: type.is(x) ? [] : [ValidationError.of(x, type, path, options.context)]\n  };\n};\n\nvalidators.list = function validateList(x, type, path, options) {\n  // x should be an array\n  if (!t.Array.is(x)) {\n    return {\n      value: x,\n      errors: [ValidationError.of(x, type, path, options.context)]\n    };\n  }\n\n  var ret = {\n    value: [],\n    errors: []\n  }; // every item should be of type `type.meta.type`\n\n  for (var i = 0, len = x.length; i < len; i++) {\n    var item = recurse(x[i], type.meta.type, path.concat(i), options);\n    ret.value[i] = item.value;\n    ret.errors = ret.errors.concat(item.errors);\n  }\n\n  return ret;\n};\n\nvalidators.subtype = function validateSubtype(x, type, path, options) {\n  // x should be a valid inner type\n  var ret = recurse(x, type.meta.type, path, options);\n\n  if (ret.errors.length) {\n    return ret;\n  } // x should satisfy the predicate\n\n\n  if (!type.meta.predicate(ret.value)) {\n    ret.errors = [ValidationError.of(x, type, path, options.context)];\n  }\n\n  return ret;\n};\n\nvalidators.maybe = function validateMaybe(x, type, path, options) {\n  return t.Nil.is(x) ? {\n    value: x,\n    errors: []\n  } : recurse(x, type.meta.type, path, options);\n};\n\nvalidators.struct = function validateStruct(x, type, path, options) {\n  // x should be an object\n  if (!t.Object.is(x)) {\n    return {\n      value: x,\n      errors: [ValidationError.of(x, type, path, options.context)]\n    };\n  } // [optimization]\n\n\n  if (type.is(x)) {\n    return {\n      value: x,\n      errors: []\n    };\n  }\n\n  var ret = {\n    value: {},\n    errors: []\n  };\n  var props = type.meta.props;\n  var defaultProps = type.meta.defaultProps || noobj; // every item should be of type `props[name]`\n\n  for (var name in props) {\n    if (props.hasOwnProperty(name)) {\n      var actual = x[name]; // apply defaults\n\n      if (actual === undefined) {\n        actual = defaultProps[name];\n      }\n\n      var prop = recurse(actual, props[name], path.concat(name), options);\n      ret.value[name] = prop.value;\n      ret.errors = ret.errors.concat(prop.errors);\n    }\n  }\n\n  var strict = options.hasOwnProperty('strict') ? options.strict : type.meta.strict;\n\n  if (strict) {\n    for (var field in x) {\n      if (x.hasOwnProperty(field) && !props.hasOwnProperty(field)) {\n        ret.errors.push(ValidationError.of(x[field], t.Nil, path.concat(field), options.context));\n      }\n    }\n  }\n\n  if (!ret.errors.length) {\n    ret.value = new type(ret.value);\n  }\n\n  return ret;\n};\n\nvalidators.tuple = function validateTuple(x, type, path, options) {\n  var types = type.meta.types;\n  var len = types.length; // x should be an array of at most `len` items\n\n  if (!t.Array.is(x) || x.length > len) {\n    return {\n      value: x,\n      errors: [ValidationError.of(x, type, path, options.context)]\n    };\n  }\n\n  var ret = {\n    value: [],\n    errors: []\n  }; // every item should be of type `types[i]`\n\n  for (var i = 0; i < len; i++) {\n    var item = recurse(x[i], types[i], path.concat(i), options);\n    ret.value[i] = item.value;\n    ret.errors = ret.errors.concat(item.errors);\n  }\n\n  return ret;\n};\n\nvalidators.dict = function validateDict(x, type, path, options) {\n  // x should be an object\n  if (!t.Object.is(x)) {\n    return {\n      value: x,\n      errors: [ValidationError.of(x, type, path, options.context)]\n    };\n  }\n\n  var ret = {\n    value: {},\n    errors: []\n  }; // every key should be of type `domain`\n  // every value should be of type `codomain`\n\n  for (var k in x) {\n    if (x.hasOwnProperty(k)) {\n      var subpath = path.concat(k);\n      var key = recurse(k, type.meta.domain, subpath, options);\n      var item = recurse(x[k], type.meta.codomain, subpath, options);\n      ret.value[k] = item.value;\n      ret.errors = ret.errors.concat(key.errors, item.errors);\n    }\n  }\n\n  return ret;\n};\n\nvalidators.union = function validateUnion(x, type, path, options) {\n  var ctor = type.dispatch(x);\n  return t.Function.is(ctor) ? recurse(x, ctor, path.concat(type.meta.types.indexOf(ctor)), options) : {\n    value: x,\n    errors: [ValidationError.of(x, type, path, options.context)]\n  };\n};\n\nvalidators.intersection = function validateIntersection(x, type, path, options) {\n  var types = type.meta.types;\n  var len = types.length;\n  var ret = {\n    value: x,\n    errors: []\n  };\n  var nrOfStructs = 0; // x should be of type `types[i]` for all i\n\n  for (var i = 0; i < len; i++) {\n    if (types[i].meta.kind === 'struct') {\n      nrOfStructs++;\n    }\n\n    var item = recurse(x, types[i], path, options);\n    ret.errors = ret.errors.concat(item.errors);\n  }\n\n  if (nrOfStructs > 1) {\n    ret.errors.push(ValidationError.of(x, type, path, options.context));\n  }\n\n  return ret;\n};\n\nvalidators['interface'] = function validateInterface(x, type, path, options) {\n  // eslint-disable-line dot-notation\n  // x should be an object\n  if (!t.Object.is(x)) {\n    return {\n      value: x,\n      errors: [ValidationError.of(x, type, path, options.context)]\n    };\n  }\n\n  var ret = {\n    value: {},\n    errors: []\n  };\n  var props = type.meta.props; // every item should be of type `props[name]`\n\n  for (var name in props) {\n    var prop = recurse(x[name], props[name], path.concat(name), options);\n    ret.value[name] = prop.value;\n    ret.errors = ret.errors.concat(prop.errors);\n  }\n\n  var strict = options.hasOwnProperty('strict') ? options.strict : type.meta.strict;\n\n  if (strict) {\n    for (var field in x) {\n      if (!props.hasOwnProperty(field) && !t.Nil.is(x[field])) {\n        ret.errors.push(ValidationError.of(x[field], t.Nil, path.concat(field), options.context));\n      }\n    }\n  }\n\n  return ret;\n};\n\nt.mixin(t, {\n  ValidationError: ValidationError,\n  ValidationResult: ValidationResult,\n  validate: validate\n});\nmodule.exports = t;","map":null,"metadata":{},"sourceType":"script"}