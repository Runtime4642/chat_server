{"ast":null,"code":"var assert = require('./assert');\n\nvar isFunction = require('./isFunction');\n\nvar isArray = require('./isArray');\n\nvar mixin = require('./mixin');\n\nvar isStruct = require('./isStruct');\n\nvar isInterface = require('./isInterface');\n\nvar isObject = require('./isObject');\n\nvar refinement = require('./refinement');\n\nvar decompose = require('./decompose');\n\nfunction compose(predicates, unrefinedType, name) {\n  var result = predicates.reduce(function (type, predicate) {\n    return refinement(type, predicate);\n  }, unrefinedType);\n\n  if (name) {\n    result.displayName = name;\n    result.meta.name = name;\n  }\n\n  return result;\n}\n\nfunction getProps(type) {\n  return isObject(type) ? type : type.meta.props;\n}\n\nfunction getDefaultProps(type) {\n  return isObject(type) ? null : type.meta.defaultProps;\n}\n\nfunction pushAll(arr, elements) {\n  Array.prototype.push.apply(arr, elements);\n}\n\nfunction extend(combinator, mixins, options) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isFunction(combinator), function () {\n      return 'Invalid argument combinator supplied to extend(combinator, mixins, options), expected a function';\n    });\n    assert(isArray(mixins), function () {\n      return 'Invalid argument mixins supplied to extend(combinator, mixins, options), expected an array';\n    });\n  }\n\n  var props = {};\n  var prototype = {};\n  var predicates = [];\n  var defaultProps = {};\n  mixins.forEach(function (x, i) {\n    var decomposition = decompose(x);\n    var unrefinedType = decomposition.unrefinedType;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isObject(unrefinedType) || isStruct(unrefinedType) || isInterface(unrefinedType), function () {\n        return 'Invalid argument mixins[' + i + '] supplied to extend(combinator, mixins, options), expected an object, struct, interface or a refinement (of struct or interface)';\n      });\n    }\n\n    pushAll(predicates, decomposition.predicates);\n    mixin(props, getProps(unrefinedType));\n    mixin(prototype, unrefinedType.prototype);\n    mixin(defaultProps, getDefaultProps(unrefinedType), true);\n  });\n  options = combinator.getOptions(options);\n  options.defaultProps = mixin(defaultProps, options.defaultProps, true);\n  var result = compose(predicates, combinator(props, {\n    strict: options.strict,\n    defaultProps: options.defaultProps\n  }), options.name);\n  mixin(result.prototype, prototype);\n  return result;\n}\n\nmodule.exports = extend;","map":null,"metadata":{},"sourceType":"script"}